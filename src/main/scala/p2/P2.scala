package p2

import java.io.File

import breeze.linalg.DenseVector
import scalismo.io._
import scalismo.sampling.algorithms._
import scalismo.sampling.evaluators._
import scalismo.sampling.loggers._
import scalismo.sampling.proposals._
import scalismo.sampling._

import scalismo.statisticalmodel.asm._
import scalismo.ui.api.SimpleAPI.ScalismoUI
import scala.util.Random

/**
  * Main working class for second project, that is a model-based segmentation
  * of 5 CT femur images using MCMC methods and Active Shape Models.
  *
  * Created by George on 20/5/2017.
  */
object P2 {

  def main(args: Array[String]) {
    scalismo.initialize()

    val ui = ScalismoUI()

    val asm: ActiveShapeModel = ActiveShapeModelIO.readActiveShapeModel(new File("handedData/femur-asm.h5")).get
    val image1 = ImageIO.read3DScalarImage[Short](new File("handedData/targets/1.nii")).get.map(_.toFloat)

    ui.show(asm.statisticalModel, "asm")
    ui.show(image1, "target")

    val logger = new AcceptRejectLogger[ShapeParameters] {

      override def accept(current: ShapeParameters, sample: ShapeParameters, generator: ProposalGenerator[ShapeParameters], evaluator: DistributionEvaluator[ShapeParameters]): Unit = {
        println(s"Accepted proposal generated by $generator (probability ${evaluator.logValue(sample)})")
      }

      override def reject(current: ShapeParameters, sample: ShapeParameters, generator: ProposalGenerator[ShapeParameters], evaluator: DistributionEvaluator[ShapeParameters]): Unit = {
        println(s"Rejected proposal generated by $generator (probability ${evaluator.logValue(sample)})")
      }
    }

    println("Defining the Markov chain...")
    val generator = GaussianProposal(asm.statisticalModel.rank, 0.1f)
    val likelihoodEvaluator = CorrespondenceEvaluator(asm)
    val priorEvaluator = ShapePriorEvaluator(asm)
    val posteriorEvaluator = ProductEvaluator(priorEvaluator, likelihoodEvaluator)
    //TODO Error:(50, 35) could not find implicit value for parameter random: scala.util.Random
    implicit val random = new Random()
    val chain = MetropolisHastings(generator, posteriorEvaluator /*, logger*/)

    val initialParameters = ShapeParameters(DenseVector.zeros[Float](asm.statisticalModel.rank))

    println("Sampling from the chain...")
    val metropolisHastingsIterator = chain.iterator(initialParameters)
    val samplingIterator = for (theta <- metropolisHastingsIterator) yield {
      ui.setCoefficientsOf("asm", theta.modelCoefficients)
      theta
    }
    val samples = samplingIterator.drop(100).take(50)

    println("Done.")
  }


}
